// ARM_Perceptron.cpp : Este archivo contiene la función "main". La ejecución del programa comienza y termina ahí.
//
#include <iostream>
#include <cstdlib>
#include <ctime>
#define MAX 10

using namespace std;
float G[MAX][MAX];
int i, j, n, u;
float const_i[MAX], const_j[MAX];
float output [MAX] ;
float entrada_1[MAX], entrada_2[MAX];

class Neurona
{
private:
	float bios;
	float peso_1;
	float peso_2;

public:
	void setbios(float bios)
	{
		this->bios = bios;
	}
	void setPeso_1(float peso_1)
	{
		this->peso_1 = peso_1;
	}
	void setPeso_2(float peso_2)
	{
		this->peso_2 = peso_2;
	}
	float getbios()
	{
		return bios;
	}
	float getPeso_1()
	{
		return peso_1;
	}
	float getPeso_2()
	{
		return peso_2;
	}
	float sigmoide(float valor)
	{
		if (valor > 0)
			return 1;
		else
			return 0;
	}
	float neurona(float entrada_1[MAX], float entrada_2[MAX])
	{
		return (bios + (entrada_1[MAX] * peso_1) + (entrada_2[MAX] * peso_2));
	}
	float salida(  float entrada_1[MAX],  float  entrada_2[MAX])
	{
		return sigmoide(neurona(entrada_1, entrada_2));
	}
};




int main()
{

	srand(time(NULL));
	Neurona neurona;

	float peso_1_anterior = 0;
	float peso_2_anterior = 0;
	float bios_anterior = 0;
	

	int condicion = 1;
	while (condicion)
	{

		condicion = 0;
		if (peso_1_anterior == 0 && peso_2_anterior == 0)
		{
			neurona.setPeso_1(rand() % (10) / 10.0);
			neurona.setPeso_2(rand() % (10) / 10.0);
			neurona.setbios(rand() % (10) / 10.0);
			peso_1_anterior = neurona.getPeso_1();
			peso_2_anterior = neurona.getPeso_2();
			bios_anterior = neurona.getbios();
		}

		cout << "peso 1: " << neurona.getPeso_1() << endl;
		cout << "peso 2: " << neurona.getPeso_2() << endl;
		cout << "bios: " << neurona.getbios() << endl;

		cout << "*peso 1: " << peso_1_anterior << endl;
		cout << "*peso 2: " << peso_2_anterior << endl;
		cout << "*bios: " << bios_anterior << endl;


		// INPUTS ONLY!

		printf("\nEnter no. of  variables:");
		scanf_s("%d", &n);

		printf("\nEnter no. of data per  variable:");
		scanf_s("%d", &u);

		printf("\nEnter the  Data matrix:\n"); // N
		printf("\n");

		for (i = 0; i < u; i++)
			for (j = 0; j < n; j++)
				scanf_s("%f", &G[i][j]);

		// OUTPUTS ONLY! (YEAH MULTIPLE OUTPUTS)

		
		

		printf("\nEnter the  Data Output vector:\n"); // N
		printf("\n");

		for (i = 0; i < u; i++)
			
				scanf_s("%f", &output[i]); 

   
	 	 printf("\nA B | X \n");
		for (i = 0; i < u; i++) {
			printf("\n");
			for (j = 0; j < n; j++) {
				
				printf("%f\t", G[i][j]);

				
				

			}
		}  

		printf("\n");

		printf("\n|X \n");
		for (i = 0; i < u; i++) {
			printf("\n");
				printf("%f\t", output[i]); // saca matriz de salida
				
		}
		printf("\n");
		
		/*
		printf("\n");
	
		cout << "A B | X" << endl;
		cout << "1 1 | " << (1) << endl;
		cout << "1 0 | " << (0) << endl;
		cout << "0 1 | " << (0) << endl;
		cout << "0 0 | " << (0) << endl;
		*/

		

		for (i = 0; i < u; i++) {
			printf("\n");
			for (j = 0; j < n; j++) {
		


				cout << "A:"<<G[i] <<"B:"<<G[j] << neurona.salida(G[i],G[j]) << endl;

				/*
				cout << "A:1 B:0 : " << neurona.salida(1, 0) << endl;
				cout << "A:0 B:1 : " << neurona.salida(0, 1) << endl;
				cout << "A:0 B:0 : " << neurona.salida(0, 0) << endl; */

				peso_1_anterior = neurona.getPeso_1();
				peso_2_anterior = neurona.getPeso_2();
				bios_anterior = neurona.getbios();


				const_i[i] = G[i];
				const_j[i] = G[j];

				if (neurona.salida(G[i],G[j]) != output[i])
					
				{


					neurona.setPeso_1(peso_1_anterior + 0.2f * (const_i[i] - neurona.salida(G[i], G[j])) * const_j[i]);
					neurona.setPeso_2(peso_2_anterior + 0.2f * (const_i[i] - neurona.salida(G[i], G[j])) * const_j[i]);
					neurona.setbios(bios_anterior + 0.2f * (const_i[i] - neurona.salida(G[i], G[j])));
					condicion = 1;
				}




				/*
				if (neurona.salida(1, 0) != 0)
				{

					neurona.setPeso_1(peso_1_anterior + 0.2f * (0 - neurona.salida(1, 0)) * 1);
					neurona.setPeso_2(peso_2_anterior + 0.2f * (0 - neurona.salida(1, 0)) * 0);
					neurona.setbios(bios_anterior + 0.2f * (0 - neurona.salida(1, 0)));
					condicion = 1;
				}
				if (neurona.salida(0, 1) != 0)
				{

					neurona.setPeso_1(peso_1_anterior + 0.2f * (0 - neurona.salida(0, 1)) * 0);
					neurona.setPeso_2(peso_2_anterior + 0.2f * (0 - neurona.salida(0, 1)) * 1);
					neurona.setbios(bios_anterior + 0.2f * (0 - neurona.salida(0, 1)));
					condicion = 1;
				}
				if (neurona.salida(0, 0) != 0)
				{

					neurona.setPeso_1(peso_1_anterior + 0.2f * (0 - neurona.salida(0, 0)) * 0);
					neurona.setPeso_2(peso_2_anterior + 0.2f * (0 - neurona.salida(0, 0)) * 0);
					neurona.setbios(bios_anterior + 0.2f * (0 - neurona.salida(0, 0)));
					condicion = 1;
				} */

			}
		}
		cout << endl;
	}
	return 0;

}




Gravedad	Código	Descripción	Proyecto	Archivo	Línea	Estado suprimido
Error (activo)	E0513	no se puede asignar un valor de tipo "float *" a una entidad de tipo "float"	ARM_Perceptron	C:\Users\user\Documents\Programacion\ARM_Perceptron\ARM_Perceptron.cpp	183	


Gravedad	Código	Descripción	Proyecto	Archivo	Línea	Estado suprimido
Error	C2440	 '=': no se puede realizar la conversión de 'float [10]' a 'float'	ARM_Perceptron	C:\Users\user\Documents\Programacion\ARM_Perceptron\ARM_Perceptron.cpp	183	
